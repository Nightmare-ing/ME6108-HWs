import math

import numpy as np

def bresenham_line_standard(start, end, subdivision):
    """
    Return a numpy array of discrete points generated by Bresenhan algorithm
    :param start: start point of the line
    :param end: end point of the line
    :param subdivision: number of divisions of the line
    :return: numpy, array of discrete points generated by Bresenhan algorithm
    """
    pixel_x = np.zeros(subdivision)
    pixel_y = np.zeros(subdivision)
    x = start[0]
    y = start[1]
    unit = (end[0] - start[0]) / subdivision
    k = float(end[1] - start[1]) / float(end[0] - start[0])
    e = -0.5
    for i in range(subdivision):
        pixel_x[i] = x
        pixel_y[i] = y
        x = x + unit
        e = e + k
        if e >= 0:
            y = y + unit
            # when move up for one pixel, should also compare with another
            # 0.5, but now the position is "negative", so it's e - 1
            e = e - 1

    return pixel_x, pixel_y


def bresenham_line_optimized(start, end, subdivision):
    """
    Optimized bresenham line algorithm with parallel computing technique
    :param start: start point of the line
    :param end: end point of the line
    :param subdivision: number of divisions of the line
    :return: numpy, array of discrete points generated by Bresenhan algorithm
    """
    num_of_points = subdivision + 1
    pixel_x = np.linspace(start[0], end[0], num_of_points)
    unit = (end[0] - start[0]) / subdivision
    k = float(end[1] - start[1]) / float(end[0] - start[0])
    e = np.arange(0, k * num_of_points, k) - 0.5
    e, _ = np.modf(e)
    e = np.where(e > 0, 1, 0) * unit
    pixel_y = np.cumsum(e) + start[1]
    return pixel_x, pixel_y
